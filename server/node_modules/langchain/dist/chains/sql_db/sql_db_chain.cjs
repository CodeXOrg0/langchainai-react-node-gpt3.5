"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlDatabaseChain = void 0;
const sql_db_prompt_js_1 = require("./sql_db_prompt.cjs");
const base_js_1 = require("../base.cjs");
const llm_chain_js_1 = require("../llm_chain.cjs");
const sql_db_js_1 = require("../../sql_db.cjs");
const index_js_1 = require("../../util/index.cjs");
const index_js_2 = require("../../base_language/index.cjs");
class SqlDatabaseChain extends base_js_1.BaseChain {
    constructor(fields) {
        const { memory } = fields;
        super(memory);
        // LLM wrapper to use
        Object.defineProperty(this, "llm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // SQL Database to connect to.
        Object.defineProperty(this, "database", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Prompt to use to translate natural language to SQL.
        Object.defineProperty(this, "prompt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sql_db_prompt_js_1.DEFAULT_SQL_DATABASE_PROMPT
        });
        // Number of results to return from the query
        Object.defineProperty(this, "topK", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 5
        });
        Object.defineProperty(this, "inputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "query"
        });
        Object.defineProperty(this, "outputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "result"
        });
        // Whether to return the result of querying the SQL table directly.
        Object.defineProperty(this, "returnDirect", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this.llm = fields.llm;
        this.database = fields.database;
        this.inputKey = fields.inputKey ?? this.inputKey;
        this.outputKey = fields.outputKey ?? this.outputKey;
    }
    async _call(values) {
        const lLMChain = new llm_chain_js_1.LLMChain({
            prompt: this.prompt,
            llm: this.llm,
            outputKey: this.outputKey,
            memory: this.memory,
        });
        if (!(this.inputKey in values)) {
            throw new Error(`Question key ${this.inputKey} not found.`);
        }
        const question = values[this.inputKey];
        let inputText = `${question}\nSQLQuery:`;
        const tablesToUse = values.table_names_to_use;
        const tableInfo = await this.database.getTableInfo(tablesToUse);
        const llmInputs = {
            input: inputText,
            top_k: this.topK,
            dialect: this.database.appDataSourceOptions.type,
            table_info: tableInfo,
            stop: ["\nSQLResult:"],
        };
        const intermediateStep = [];
        const sqlCommand = await lLMChain.predict(llmInputs);
        intermediateStep.push(sqlCommand);
        let queryResult = "";
        try {
            queryResult = await this.database.appDataSource.query(sqlCommand);
            intermediateStep.push(queryResult);
        }
        catch (error) {
            console.error(error);
        }
        let finalResult;
        if (this.returnDirect) {
            finalResult = { result: queryResult };
        }
        else {
            inputText += `${+sqlCommand}\nSQLResult: ${JSON.stringify(queryResult)}\nAnswer:`;
            llmInputs.input = inputText;
            finalResult = { result: await lLMChain.predict(llmInputs) };
        }
        return finalResult;
    }
    _chainType() {
        return "sql_database_chain";
    }
    get inputKeys() {
        return [this.inputKey];
    }
    static async deserialize(data) {
        const serializedLLM = await (0, index_js_1.resolveConfigFromFile)("llm", data);
        const llm = await index_js_2.BaseLanguageModel.deserialize(serializedLLM);
        const serializedDatabase = await (0, index_js_1.resolveConfigFromFile)("sql_database", data);
        const sqlDataBase = await sql_db_js_1.SqlDatabase.fromOptionsParams(serializedDatabase);
        return new SqlDatabaseChain({
            llm,
            database: sqlDataBase,
        });
    }
    serialize() {
        return {
            _type: this._chainType(),
            llm: this.llm.serialize(),
            sql_database: this.database.serialize(),
        };
    }
}
exports.SqlDatabaseChain = SqlDatabaseChain;
//# sourceMappingURL=sql_db_chain.js.map